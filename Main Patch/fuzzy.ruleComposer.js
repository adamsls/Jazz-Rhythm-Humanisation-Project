//FUZZYLIB, by Alain Bonardi, Isis Truck and Nicolas Jouandeau////Javascript version for Max/MSP////ruleComposer object//////2007-2008////_____________________________________________________________________////CONSTANTES////type of errors met////////Linguistic Variables Types///*const RCFI_ID = 0;const OLV_ID = 1;*///ARBITRARY MIN AND MAX FLOAT VALUES//const MAX_APP = 1234567890.0;const MIN_APP = -1234567890.0;//NONAME CONSTANTconst NONAME = "NONAME";//IS_NONE CONSTANTconst IS_NONE = -1;//______________________________________________________////CONSTANTS ONLY FOR FUZZY RULES//const UNDERSCORE_ID = "_";//const AND_CHAR_ID = "&";//const OR_CHAR_ID = "|";const SPACE_CHAR_ID = " ";const LEFT_PARENTHESIS_ID = "(";const RIGHT_PARENTHESIS_ID = ")";const CONDITION_ID = 0;const CONSEQUENT_ID = 1;//const AND_OPERATION_ID = 0;const OR_OPERATION_ID = 1;////const ENG_LANGUAGE = 0;const FR_LANGUAGE = 1;const C_LANGUAGE = 2;//const ENG_LANGUAGE_ID = "eng";const FR_LANGUAGE_ID = "fr";const C_LANGUAGE_ID = "c";//_____________________________________________________________________////defines 1 inlet////to receive the inputs////it can receive the messages from the LV objects and parameters//inlets = 1;//defines 4 outlets////outlet 0 sends the defuzzified results////outlet 1 sends the fss data to the js user interface////outlet 2 sends info to the ruleComposer object////outlet 3 sends the warning and error messages////outlet 4 sends the feedback info to the control interface panel//outlets = 2;////constantes pour désigner les sorties////const MANAGE_OUTLET = 0;//_____________________________________________________________________////global variables//var myLVNames = new Array();var myLVNames_Sorted = new Array();var myFSSNames = new Array();var operation = [" and ", " or "];var IF_ID = "if";var THEN_ID = "then";var EQUALS_ID = " is ";var DIFFERENT_ID = " is_not ";var ruleComposerInformedOfLanguage = false;//_____________________________________________________________________//////_____________________________________________________________________//function LVCreated(x){	var n, i, j, nFSS;	//	//post("LV ", arguments[0], " with ", arguments[1], " FSS\n");	j = looksForLVName(arguments[0]);	if (j > -1)	{		//post("LV already added\n");	}	else	{		//post("Add new LV\n");		myLVNames.push(arguments[0]);		myLVNames_Sorted.push(arguments[0]);		n = myLVNames.length;		nFSS = arguments[1];		myFSSNames[n-1] = new Array();		for (i = 0; i < nFSS; i++)		{			myFSSNames[n-1].push(arguments[2+i]);			//post("Attached FSS = ", arguments[2+i], "\n");		}		//sort the list of LV//		myLVNames_Sorted.sort();		//		//send the list of LV to the output//		outlet(MANAGE_OUTLET, "LV", "clear");		for (i = 0; i < myLVNames_Sorted.length; i++)		{			outlet(MANAGE_OUTLET, "LV", "append", myLVNames_Sorted[i]);			//post("Sorted\n");		}	}}//_____________________________________________________________________//////_____________________________________________________________________//function LVRemoved(x){	var lv, j, i, n;	var tab1 = new Array();	lv = arguments[0];	j = looksForLVName(lv);	if (j != IS_NONE)	{		post("Updating rule composer by deleting LV = ", lv, "\n");		n = myLVNames.length;		tab1 = myLVNames.slice(0, j);		if (j < n-1)		{			tab2 = myLVNames.slice(j+1, n);			myLVNames = tab1.concat(tab2);		}		else		{			myLVNames = tab1;		}		//		//impact myFSSNames		//we remove the rank #j//		n = myFSSNames.length;		tab1 = myFSSNames.slice(0, j);		if (j < n-1)		{			tab2 = myFSSNames.slice(j+1, n);			myFSSNames = tab1.concat(tab2);		}		else		{			myFSSNames = tab1;		}		//		myLVNames_Sorted = new Array();		myLVNames_Sorted = myLVNames;		myLVNames_Sorted.sort();			outlet(MANAGE_OUTLET, "LV", "clear");		for (i = 0; i < myLVNames_Sorted.length; i++)		{			outlet(MANAGE_OUTLET, "LV", "append", myLVNames_Sorted[i]);			//post("Sorted\n");		}	}}//_____________________________________________________________________//////_____________________________________________________________________//function LanguageTerms(x){	//post("Operation[0]=", arguments[0], "Operation[1]=", arguments[1], "IF_ID=", arguments[2], "THEN_ID=", arguments[3], "EQUALS_ID=", arguments[4], "DIFFERENT_ID=", arguments[5], "\n");	operation[0] = arguments[0];	operation[1] = arguments[1];	IF_ID = arguments[2];	THEN_ID = arguments[3];	EQUALS_ID = arguments[4];	DIFFERENT_ID = arguments[5];	outlet(MANAGE_OUTLET, "EQUALS", "clear");	outlet(MANAGE_OUTLET, "EQUALS", "append", EQUALS_ID.slice(1, EQUALS_ID.length-1));	outlet(MANAGE_OUTLET, "EQUALS", "append", DIFFERENT_ID.slice(1, DIFFERENT_ID.length-1));	outlet(MANAGE_OUTLET, "OPERATION", "clear");	outlet(MANAGE_OUTLET, "OPERATION", "append", operation[0].slice(1, operation[0].length-1));	outlet(MANAGE_OUTLET, "OPERATION", "append", operation[1].slice(1, operation[1].length-1));	outlet(MANAGE_OUTLET, "IF", IF_ID);	outlet(MANAGE_OUTLET, "THEN", THEN_ID);}//_____________________________________________________________________//////_____________________________________________________________________//function sendFSSNames(x){	var i, j, n;	j = looksForLVName(arguments[0]);	n = myFSSNames[j].length;	outlet(MANAGE_OUTLET, "FSS", "clear");	for (i = 0; i < n; i++)	{		outlet(MANAGE_OUTLET, "FSS", "append", myFSSNames[j][i]);	}}//_____________________________________________________________________////Resets basic info of RuleComposerObject//_____________________________________________________________________//function ruleComposerReset(){	myLVNames = new Array();	myLVNames_Sorted = new Array();	myFSSNames = new Array();}//Fonctions utilitaires////_____________________________________________________________________////Ordering classification (an element cannot be inserted twice)//_____________________________________________________________________//function insertIntoList(x, myList){	//post("insertIntoListFunction x = ", x, "\n");	var i, n;	var myNewList = new Array();		//	myNewList = myList;	n = myList.length;	//post("Size = ", n, "\n");	if ((n == 0) || (x > myList[n-1]))	{		//insertion on the right//		//post("Insertion on the right\n");		myNewList.push(x);		return myNewList;	}	else	{		if (x < myList[0])		{			//post("Insertion on the left\n");			myNewList.unshift(x);			return myNewList;		}		else		{			//post("Insertion among elements\n");			i = 0;			while ((i < n) && (x > myList[i]))			{				i += 1;			}			//at the end, either it is the end of the list or we found a place for insertion//			if ((i < n) && (x != myList[i]))			{				//the place can only be < n since we already dealt wth the insertion on the right//				var tab1 = new Array();				var tab2 = new Array();				tab1 = myList.slice(0, i);				tab2 = myList.slice(i, n);				tab1.push(x);				myNewList = tab1.concat(tab2);				return myNewList;			}			else			{				//element already present//				return myList;			}		}	}}//_____________________________________________________________________////Computes intersection of two segments//Segment 1 is defined by 2 points: (xa, y1a) (xb, y1b)//Segment 2 is defined by 2 points: (xa, y2a) (xb, y2b)//They have the same abscissa at beginning and end: xa and xb//_____________________________________________________________________//function segmentIntersection(xa, y1a, y2a, xb, y1b, y2b){	var dx, dy1, dy2, slope1, slope2, origOrdinate1, origOrdinate2, intersectionOrdinate, intersectionAbscissa;	//the result of the intersection is an array//	//with three values//	//item 0 is the result of the intersection : -1 for parallel segments, 0 for secant segments with intersection in the interval//	//item 1 is the abscissa of the intersection if applicable//	//item 2 is the ordinate of the intersection if applicable//	var intersection = new Array(3);	//	dx = xb-xa;	dy1 = y1b - y1a;	dy2 = y2b - y2a;	slope1 = dy1 / dx;	slope2 = dy2 / dx;	if (slope1 == slope2)	{		//post("Parallel segments\n");		//segments are parallel//		intersection[0] = IS_NONE;		intersection[1] = IS_NONE;		intersection[2] = IS_NONE;		return intersection;	}	else	{		//post("Intersection of segments  \n");		//there is an intersection of the two segments//		origOrdinate1 = (y1a * xb - y1b * xa)/dx;		origOrdinate2 = (y2a * xb - y2b * xa)/dx;		intersectionOrdinate = (slope1 * origOrdinate2 - slope2 * origOrdinate1) / (slope1 - slope2);		intersectionAbscissa = (origOrdinate2 - origOrdinate1) / (slope1 - slope2);		if ((intersectionAbscissa > xa) && (intersectionAbscissa < xb))			{			//if the intersection abscissa belongs to [xa, xb], we have to insert a new point in the FSS : the intersection point//			//post("Insertion intersection=", intersectionAbscissa, intersectionOrdinate, "\n");			intersection[0] = 0;			intersection[1] = intersectionAbscissa;			intersection[2] = intersectionOrdinate;			//post("After insertion \n");		}		else		{			intersection[0] = IS_NONE;			intersection[1] = IS_NONE;			intersection[2] = IS_NONE;		}		return intersection;	}}//_____________________________________________________________________//////_____________________________________________________________________//function maxArgumentsToString(x, sep){	var s1 = "";	var s2;	var i;	for (i = 0; i < x.length; i++)	{		s2 = String(x[i]);		//post(s2, "\n");		if (sep == false)		{			s1 = s1+s2;		}		else		{			if (i > 0)			{				//on ajoute " " et le nouveau "terme" sauf pour le 1er, où l'on prend directement le nouveau terme//				s1=s1+" "+s2;			}			else			{				s1 = s2;			}		}		//post(s1, "\n");	}	return s1;}//_____________________________________________________________________////Looks for lvName in the LVNames array////returns either its index if found or (-1) if not found////_____________________________________________________________________//function looksForLVName(lvName){	var i, n, trouve;	n = myLVNames.length;	trouve = IS_NONE;	i = 0;	if (n > 0)	{		do		{			//post(i, "eme comparison ->", lvName, myLVNames[i], "\n");			if (lvName == myLVNames[i])			{				trouve =i;			}			i += 1;		} while ((i < n) && (trouve < 0))	}	//post("trouve = ", trouve, "\n");	return trouve;}//_____________________________________________________________________////Looks for fssName in the fssNames double array for a precise LV////returns either its index if found or (-1) if not found////_____________________________________________________________________//function looksForFSSName(fssName, nLV){	var i, n , trouve;	trouve = IS_NONE;	if (nLV > IS_NONE)	{		n = myFSSNames[nLV].length;		i = 0;		if (n > 0)		{			do			{				if (fssName == myFSSNames[nLV][i])				{					trouve = i;				}				i += 1;			} while ((i < n) && (trouve < 0))		}	}	return trouve;}//_____________________________________________________________________//////_____________________________________________________________________//function addsLVname(lvName){	//post("addsLVName\n");	myLVNames.push(lvName);}//_____________________________________________________________________//////_____________________________________________________________________//function displaysLVNames(){	var i, n;	n = myLVNames.length;	for (i = 0; i < n; i++)	{		post("LV # ", i, " is ", myLVNames[i], "\n");	}}//_____________________________________________________________________////_____________________________________________________________________//function isExpectedChar(x){	if ((x != SPACE_CHAR_ID) && (x != LEFT_PARENTHESIS_ID) && (x != RIGHT_PARENTHESIS_ID))	{		return false;	}	else	{		return true;	}}//_____________________________________________________________________////_____________________________________________________________________//function containsOperation(x, i){	var j, n, l, trouve;	n = operation.length;	j = 0;	trouve = IS_NONE	do	{		l = operation[j].length;		if (x.slice(i, i+l) == operation[j])		{			trouve = j;		}		j += 1;			} while (j < n);	return trouve;}//_____________________________________________________________________//function checkParentheses(x){	var openingParenthesisNbr, closingParenthesisNbr;	var i, n;	//	n = x.length;	openingParenthesisNbr = 0;	closingParenthesisNbr = 0;	//post("expression = ", x, "\n");	for (i = 0; i < n; i++)	{		//post(x.charAt(i), "\n");		if (x.charAt(i) == LEFT_PARENTHESIS_ID)		{			openingParenthesisNbr += 1;		}		else		{			if (x.charAt(i) == RIGHT_PARENTHESIS_ID)			{				closingParenthesisNbr += 1;			}		}	}	if (openingParenthesisNbr == closingParenthesisNbr)	{		//post(openingParenthesisNbr, " ( + ", closingParenthesisNbr, " ) \n");		return true;	}	else	{		if (openingParenthesisNbr > closingParenthesisNbr)		{			//post("____________________expression : ", x, "\n");			//post("Too many opening parentheses : ", openingParenthesisNbr-closingParenthesisNbr, "more than required\n");			outlet(MESSAGE_OUTLET, "expression", x, "has", openingParenthesisNbr-closingParenthesisNbr, "opening parentheses more than required");			//this.errorMessage.push(x.concat(" has too many opening parentheses"));			return false;		}		if (closingParenthesisNbr > openingParenthesisNbr)		{			//post("____________________expression : ", x, "\n");			//post("Too many closing parentheses : ", -openingParenthesisNbr+closingParenthesisNbr, "more than required\n");			outlet(MESSAGE_OUTLET, "expression", x, "has", -openingParenthesisNbr+closingParenthesisNbr, "closing parentheses more than required");			//this.errorMessage.push(x.concat(" has too many closing parentheses"));			return false;		}	}}//_____________________________________________________________________//function getHighestOperationIndex(x){	var i, n;	var openingParenthesisNbr, trouve, levelTrouve;		n = x.length;	openingParenthesisNbr = 0;	trouve = IS_NONE;	levelTrouve = MAX_APP;		for (i = 0; i < n; i++)	{		if (x.charAt(i) == LEFT_PARENTHESIS_ID)		{			openingParenthesisNbr += 1;		}		else		{			if (x.charAt(i) == RIGHT_PARENTHESIS_ID)			{				openingParenthesisNbr -= 1;			}			else			{				if (containsOperation(x, i) > IS_NONE)					{						if (openingParenthesisNbr < levelTrouve)						{							trouve = i;							levelTrouve = openingParenthesisNbr;						}					}			}		}	}	return trouve;}//_____________________________________________________________________//function removeParentheses(x){	var i, leftP, rightP, xBis;	xBis = x;	i = 0;	do	{		if ((xBis.charAt(i) == LEFT_PARENTHESIS_ID) || (xBis.charAt(i) == RIGHT_PARENTHESIS_ID))		{			leftP = xBis.slice(0, i);			rightP = xBis.slice(i+1, xBis.length);			xBis = leftP.concat(rightP);			//in this case, we start the next loop from the same position since everything has been shifted//		}		else		{		i += 1;		}	} while (i < xBis.length);	return xBis;}//_____________________________________________________________________//////_____________________________________________________________________//function computeOperation(x, y, opID){	//post("x = ", x, "y = ", y, "opID = ", opID);	//post("myDualTNormAndCoNorm = ", myDualTNormAndCoNorm, "\n");	switch(opID)	{		case AND_OPERATION_ID:		switch (myDualTNormAndCoNorm)		{			case DUAL_MIN_MAX:			return LV_implementedOperation(TNORM_MIN, x, y);			case DUAL_PROD_SUMMINUSPROD:			return LV_implementedOperation(TNORM_PROD, x, y);			case DUAL_MAXSUM_MINSUM:			return LV_implementedOperation(TNORM_MAXSUM, x, y);		}		break;		//		case OR_OPERATION_ID:		//post("OR_OPERATION\n");		switch (myDualTNormAndCoNorm)		{			case DUAL_MIN_MAX:			//post("value is ", tNormOrCoNorm(TCONORM_MAX, x, y), "\n");			return LV_implementedOperation(TCONORM_MAX, x, y);			case DUAL_PROD_SUMMINUSPROD:			return LV_implementedOperation(TCONORM_SUMMINUSPROD, x, y);			case DUAL_MAXSUM_MINSUM:			return LV_implementedOperation(TNORM_MINSUM, x, y);		}		break;	}}//_____________________________________________________________________//////_____________________________________________________________________//function setLanguage(l){	switch(l)	{		case ENG_LANGUAGE:		languageAdaptation(ENG_LANGUAGE_ID);		break;		//		case FR_LANGUAGE:		languageAdaptation(FR_LANGUAGE_ID);		break;		//		case C_LANGUAGE:		languageAdaptation(C_LANGUAGE_ID);		break;	}}//_____________________________________________________________________//////_____________________________________________________________________//function setDualTNormAndCoNorm(t){	switch(t)	{		case DUAL_MIN_MAX:		dualTNormCoNorm(DUAL_MIN_MAX_ID);		break;		case DUAL_PROD_SUMMINUSPROD:		dualTNormCoNorm(DUAL_PROD_SUMMINUSPROD_ID);		break;		case DUAL_MAXSUM_MINSUM:		dualTNormCoNorm(DUAL_MAXSUM_MINSUM_ID);		break;	}}//_____________________________________________________________________//////_____________________________________________________________________//function setFuzzyImplication(fi){	switch(fi)	{		case FI_REICHENBACH:		fuzzyImplication(FI_REICHENBACH_ID);		break;				case FI_WILLMOTT:		fuzzyImplication(FI_WILLMOTT_ID);		break;				case FI_RESCHER_GAINES:		fuzzyImplication(FI_RESCHER_GAINES_ID);		break;				case FI_KLEENE_DIENES:		fuzzyImplication(FI_KLEENE_DIENES_ID);		break;				case FI_BROUWER_GOEDEL:		fuzzyImplication(FI_BROUWER_GOEDEL_ID);		break;		case FI_GOGUEN:		fuzzyImplication(FI_GOGUEN_ID);		break;		case FI_LUKASIEWICZ:		fuzzyImplication(FI_LUKASIEWICZ_ID);		break;				case FI_MAMDANI:		fuzzyImplication(FI_MAMDANI_ID);		break;				case FI_LARSEN:		fuzzyImplication(FI_LARSEN_ID);		break;	}}//_____________________________________________________________________////_____________________________________________________________________//////FUZZY SUBSET PROTOTYPE - DATA AND METHODS//////_____________________________________________________________________////_____________________________________________________________________//function FSS(fssName){	this.fssName = fssName;	this.coordX = new Array();	this.coordY = new Array();	//methods//	this.FSS_Fill = FSS_Fill;	this.FSS_GetMembershipValue = FSS_GetMembershipValue;	this.FSS_Display = FSS_Display;	this.FSS_MultiDisplay = FSS_MultiDisplay;	this.FSS_TextDisplay = FSS_TextDisplay;	this.FSS_Insert = FSS_Insert;	this.FSS_Fuzzyfication = FSS_Fuzzyfication;	this.FSS_GetYMin = FSS_GetYMin;	this.FSS_GetYMax = FSS_GetYMax;	this.FSS_GetFSSName = FSS_GetFSSName;	this.FSS_SetFSSName = FSS_SetFSSName;	this.FSS_GetCoordX = FSS_GetCoordX;	this.FSS_GetCoordY = FSS_GetCoordY;	this.FSS_SetCoordX = FSS_SetCoordX;	this.FSS_SetCoordY = FSS_SetCoordY;	this.FSS_GetNumberOfCoord = FSS_GetNumberOfCoord;	this.FSS_AppendPoint = FSS_AppendPoint;	this.FSS_Simplify = FSS_Simplify;	this.FSS_CopyFrom = FSS_CopyFrom;	this.FSS_Defuzzification = FSS_Defuzzification;	this.FSS_BuildFuzzyImplicationFrom = FSS_BuildFuzzyImplicationFrom;	this.FSS_PrependPoint = FSS_PrependPoint;	this.FSS_InsertPointAtPosition = FSS_InsertPointAtPosition;	this.FSS_CompleteWithZeros = FSS_CompleteWithZeros;	this.FSS_GetSuperiorIndexOfXValue = FSS_GetSuperiorIndexOfXValue;	this.FSS_GetNumberOfIdenticalXValueFrom = FSS_GetNumberOfIdenticalXValueFrom;	//this.FSS_GetYCoordinatesAt = FSS_GetYCoordinatesAt;}//_____________________________________________________________________//function FSS_Fill(x){	var i, n;	n = arguments.length / 2;	this.coordX = new Array(n);	this.coordY = new Array(n);	for (i = 0; i < n; i++)	{		this.coordX[i] = arguments[2*i];		this.coordY[i] = arguments[2*i+1];	}}//_____________________________________________________________________//function FSS_AppendPoint(x,y){	this.coordX.push(x);	this.coordY.push(y);}//_____________________________________________________________________//function FSS_Simplify(){	//this function removes points of the FSS that are no use//	//it means points who are identical to the previous and next ones//	var i, y0, y1, y2, x0, x1;	var begTabX, endTabX, begTabY, endTabY;	var simplificationNumber = 0;	//	i = 1;	//post("_____Simplification\n");	//this.FSS_TextDisplay();	do	{		x1 = this.coordX[i-1];		y1 = this.coordY[i-1];		x0 = this.coordX[i];		y0 = this.coordY[i];		y2 = this.coordY[i+1];		if (((y1 == y0) && (y2 == y0)) || ((x1 == x0) && (y1 == y0)))		{			//remove ith point//			begTabX = this.coordX.slice(0, i);			endTabX = this.coordX.slice(i+1, this.coordX.length);			begTabY = this.coordY.slice(0, i);			endTabY = this.coordY.slice(i+1, this.coordY.length);			this.coordX = begTabX.concat(endTabX);			this.coordY = begTabY.concat(endTabY);			simplificationNumber += 1;			//this.FSS_TextDisplay();		}		else		{			i += 1;		}	} while (i < this.coordX.length-1)	//post("nbr of simplications = ", simplificationNumber, "\n");}//_____________________________________________________________________//function FSS_Display(num){	//to send the values to the Javascript graphic interface//	outlet(FSS_OUTLET, "fuzzySubset", this.fssName, num, this.coordX, this.coordY);}//_____________________________________________________________________//function FSS_MultiDisplay(num, LVLabel){	//to send the values to the Javascript graphic interface//	//post("LVLabel=", LVLabel, "num=", num, "\n");	//outlet(1, LVLabel, "fuzzySubset", this.fssName, num, this.coordX, this.coordY);	outlet(FSS_OUTLET, LVLabel, "fuzzySubset", this.fssName, num, this.coordX, this.coordY);}//_____________________________________________________________________//function FSS_TextDisplay(){	var i;	post(this.fssName);	for (i = 0; i < this.coordX.length; i++)	{		post(this.coordX[i]," ", this.coordY[i], " ");	}	post("\n");}//_____________________________________________________________________//function FSS_Fuzzyfication(x, dataMin, dataMax, fuzzyficationMethodID, halfKernelValue, leftBoundaryValue, rightBoundaryValue){	var a, b, c, d, dx;	dx = dataMax-dataMin;	//post("fuzzyfication", x, dataMin, dataMax, fuzzyficationMethodID, "\n");	switch(fuzzyficationMethodID)	{			case TRIANGULAR_PERCENT:			//post("Fuzzification\n");			this.FSS_Fill(x-dx*leftBoundaryValue, 0.0, x, 1.0, x+dx*rightBoundaryValue, 0.0);			break;			case TRIANGULAR_ABSOLUTE:			this.FSS_Fill(x - leftBoundaryValue, 0.0, x, 1.0, x + rightBoundaryValue, 0.0);			break;			case TRAPEZOIDAL_PERCENT:			b = x - dx*halfKernelValue;			c = x + dx*halfKernelValue;			a = b - dx*leftBoundaryValue;			d = c + dx*rightBoundaryValue;			//post("fuzzy ->", a, b, c, d, "\n");			this.FSS_Fill(a, 0.0, b, 1.0, c, 1.0, d, 0.0);			break;			case TRAPEZOIDAL_ABSOLUTE:			b = x - halfKernelValue;			c = x + halfKernelValue;			a = b - leftBoundaryValue;			d = c + rightBoundaryValue;			this.FSS_Fill(a, 0.0, b, 1.0, c, 1.0, d, 0.0);			break;								case SINGLETON:			this.FSS_Fill(x, 1.0, x, 0.0);			break;	}}//_____________________________________________________________________//function FSS_GetMembershipValue(x){	var i = 0;	var n;	var memberShipValue = 0.0;	var trouve = 0;	n = this.coordX.length;	if ((x < this.coordX[0]) || (x > this.coordX[n-1]))	{		//post("0 direct, en dehors du support\n");		memberShipValue = 0.0;	}	else	{		do		{			//post("******->x=", x, " i=", i, " xi=", this.coordX[i], " xi+1=", this.coordX[i+1], " yi=", this.coordY[i], "yi+1=", this.coordY[i+1], "\n");			if (x == this.coordX[i])			{				memberShipValue = this.coordY[i];				trouve = 1;				//post("exact xi - membership = ", memberShipValue, "\n");			}			else			{				if (x == this.coordX[i+1])				{					memberShipValue = this.coordY[i+1];					trouve = 1;					//post("exact xi - membership = ", memberShipValue, "\n");				}				else				{					if ((x > this.coordX[i]) && (x < this.coordX[i+1]))					{						if (this.coordX[i+1] == this.coordX[i])						{							memberShipValue = this.coordY[i];							//post("xi = xi+1 - membership = ", memberShipValue, " i=", i, "\n");							trouve = 1;						}						else						{							memberShipValue = this.coordY[i]+(x-this.coordX[i])/(this.coordX[i+1]-this.coordX[i])*(this.coordY[i+1]-this.coordY[i]);							//post("normal computation - membership = ", memberShipValue, " i=", i, "\n");							trouve = 1;						}					}				}			}			i += 1;		} while ((i < n-1) && (trouve == 0));	}	return memberShipValue;}//_____________________________________________________________________//function FSS_GetYMin(){	var mi = MAX_APP;	var i;	for (i=0; i < this.coordY.length; i++)	{		if (this.coordY[i] < mi)		{			mi = this.coordY[i];		}	}	return mi;}//_____________________________________________________________________//function FSS_GetYMax(){	var ma = MIN_APP;	var i;	for (i=0; i < this.coordY.length; i++)	{		if (this.coordY[i] > ma)		{			ma = this.coordY[i];		}	}	return ma;}//_____________________________________________________________________//function FSS_GetFSSName(){	return this.fssName;}//_____________________________________________________________________//function FSS_SetFSSName(fssName){	this.fssName = fssName;}//_____________________________________________________________________//function FSS_GetCoordX(i){	return this.coordX[i];}//_____________________________________________________________________//function FSS_GetCoordY(i){	return this.coordY[i];}//_____________________________________________________________________//function FSS_SetCoordX(x, i){	this.coordX[i] = x;}//_____________________________________________________________________//function FSS_SetCoordY(y, i){	this.coordY[i] = y;}//_____________________________________________________________________//function FSS_GetNumberOfCoord(){	return this.coordX.length;}//_____________________________________________________________________//function FSS_Insert(x, y){	//to insert in right position x and y//	var i = 0, trouve = 0;	var n;	var tab1X, tab2X, tab1Y, tab2Y, tx, ty;	tx = new Array(1);	tx[0] = x;	ty = new Array(1);	ty[0] = y;	n = this.FSS_GetNumberOfCoord();	//post("Insertion of ", x, " and ", y, "\n");	if (n == 0)	{		//the FSS is still empty//		//post("empty fss\n");		this.coordX = new Array(1);		this.coordY = new Array(1);		this.coordX[0] = x;		this.coordY[0] = y;		trouve = 1;		//post("insertion at rank 0 in empty array\n");	}	else	{		if (x > this.coordX[n-1])		{			//the element to add is greater than the greater of elements already in the FSS//			this.coordX[n] = x;			this.coordY[n] = y;			trouve = 1;			//post("insertion at end at rank ", n, "\n");		}		else		{			do			{				//post("after do -> i = ", i, " trouve = ", trouve," x = ", x, " coordX[i] = ", this.coordX[i], "\n");				if (x < this.coordX[i])				{					//post("after if x < coordX -> i = ", i, " x = ", x, " coordX[i] = ", this.coordX[i], "\n");					trouve = 1;					tab2X = this.coordX.slice(i, this.coordX.length);//slice does not include the last indexed element//					tab2Y = this.coordY.slice(i, this.coordY.length);					if (i > 0)					{						tab1X = this.coordX.slice(0, i);						tab1Y = this.coordY.slice(0, i);						this.coordX = tab1X.concat(tx);						this.coordY = tab1Y.concat(ty);						this.coordX = this.coordX.concat(tab2X);						this.coordY = this.coordY.concat(tab2Y);					}					else					{						//the element to insert is in first position//						this.coordX = tx.concat(tab2X);						this.coordY = ty.concat(tab2Y);					}				}				else				{					if (x == this.coordX[i])					{						//element already inserted//						trouve = 1;					}					else					{						//element to be inserted on the right//						i += 1;					}				}			} while ((i < n) && (trouve == 0));		}		//if (trouve == 1)//		{//			post("insertion at rank ", i, "\n");//			this.FSS_TextDisplay();//		}		//else		//{			//post("no insertion possible\n");		//}	}}//_____________________________________________________________________//////_____________________________________________________________________//function FSS_PrependPoint(x,y){	//	this.coordX.unshift(x);	this.coordY.unshift(y);}//_____________________________________________________________________//////_____________________________________________________________________//function FSS_InsertPointAtPosition(x, y, i){	var tab1 = new Array();	var tab2 = new Array();	//	//insertion into coordX array//	tab1 = this.coordX.slice(0, i);	tab2 = this.coordX.slice(i, this.coordX.length);	tab1.push(x);	this.coordX = tab1.concat(tab2);	//insertion into coordY array//	tab1 = this.coordY.slice(0, i);	tab2 = this.coordY.slice(i, this.coordY.length);	tab1.push(y);	this.coordY = tab1.concat(tab2);}//_____________________________________________________________________//////_____________________________________________________________________//function FSS_CompleteWithZeros(dmin, dmax){	var x0, y0;	x0 = this.coordX[0];	y0 = this.coordY[0];	//post("Ajout 1er point => x0=", x0, " y0=", y0, "\n");	if ((y0 != 0.0) && (x0 > dmin))	{		//we add an initial point on the x axis only if the fss does not start at dmin//		this.FSS_PrependPoint(x0, 0.0);	}	x0 = this.coordX[this.coordX.length-1];	y0 = this.coordY[this.coordY.length-1];	//post("Ajout dernier point => x0=", x0, " y0=", y0, "\n");	if ((y0 != 0.0) && (x0 < dmax))	{		//we add a terminal point on the x axis only if the fss does not end at dmax//		this.FSS_AppendPoint(x0, 0.0);	}}//_____________________________________________________________________//////_____________________________________________________________________//function FSS_CopyFrom(fss2){	var i, n;	this.fssName = fss2.FSS_GetFSSName();	n = this.FSS_GetNumberOfCoord();	this.coordX = new Array();	this.coordY = new Array();	for (i = 0; i < n; i++)	{		this.coordX.push(fss2.FSS_GetCoordX(i));		this.coordY.push(fss2.FSS_GetCoordY(i));	}}//var modellingFSS;//var fssVal;//_____________________________________________________________________//////_____________________________________________________________________//function FSS_Defuzzification(){	var i, n, num, den, x0, y0, x1, y1;	num =  0;	den = 0;	n = this.FSS_GetNumberOfCoord();	for (i = 1; i < n; i++)	{		x0 = this.coordX[i-1];		y0 = this.coordY[i-1];		x1 = this.coordX[i];		y1 = this.coordY[i];		num += (x1-x0)*((2*x1+x0)*y1+(2*x0+x1)*y0);		den += (x1-x0)*(y1+y0);	}	if (den == 0)	{		return 0;	}	else	{		return (num/(3*den));	}}//_____________________________________________________________________//////_____________________________________________________________________//function FSS_BuildFuzzyImplicationFrom(fa, fi, dmin, dmax){	var i, n, x, y;	var resultFSS = new FSS("");		//	n = this.coordX.length;	//post("n=", n, "\n");	//this.FSS_TextDisplay();		//post("FuzzyImplication\n");	//post("x=", x, "y=", y, "\n");	switch(fi)	{		//_____________________________________________________________________//		case FI_REICHENBACH:		//post("fa=", fa, "\n");		for (i=0; i < n; i++)		{			x = this.coordX[i];			y = this.coordY[i];			resultFSS.FSS_AppendPoint(x, 1.0-fa+fa*y);		}		resultFSS.FSS_CompleteWithZeros(dmin, dmax);		//post("\n\n");		//post("Fuzzy Implication ->");		//resultFSS.FSS_TextDisplay();		break;				//_____________________________________________________________________//		case FI_WILLMOTT:		var fss1 = new FSS("");		var fss2 = new FSS("");		var fss3 = new FSS("");		//Build Min(fa, fB) FSS//		//first build fa constant FSS, then operate min with current FSS//		//fss1.FSS_AppendPoint(this.coordX[0], 0.0);		fss1.FSS_AppendPoint(this.coordX[0], fa);		fss1.FSS_AppendPoint(this.coordX[n-1], fa);		//fss1.FSS_AppendPoint(this.coordX[n-1], 0.0);		fss2 = LV_Operation(TNORM_MIN, fss1, this, dmin, dmax);		//Build Max(1-fa, previous min)//		//fss3.FSS_AppendPoint(this.coordX[0], 0.0);		fss3.FSS_AppendPoint(this.coordX[0], 1.0-fa);		fss3.FSS_AppendPoint(this.coordX[n-1], 1.0-fa);		//fss3.FSS_AppendPoint(this.coordX[n-1], 0.0);		resultFSS = LV_Operation(TCONORM_MAX, fss3, fss2, dmin, dmax);		//post("Fuzzy Implication ->");		//resultFSS.FSS_TextDisplay();		break;				//_____________________________________________________________________//		case FI_RESCHER_GAINES:		var fss1 = new FSS("");		//Build Max(fa, fb) FSS//		//First build fa constant FSS//		fss1.FSS_AppendPoint(this.coordX[0], fa);		fss1.FSS_AppendPoint(this.coordX[n-1], fa);		resultFSS = LV_Operation(TNORM_MIN, fss1, this, dmin, dmax);		//Then replace fa values by 0, and other values greater than fa by 1//		n = resultFSS.FSS_GetNumberOfCoord();		for (i=0; i < n; i++)		{			y = resultFSS.FSS_GetCoordY(i);			//post("y=", y, "fa=", fa, "\n");			if (y >= fa)			{				resultFSS.FSS_SetCoordY(1.0, i);			}			else			{				resultFSS.FSS_SetCoordY(0.0, i);			}		}		//		i = 0;		while (i < resultFSS.FSS_GetNumberOfCoord())		{			x = resultFSS.FSS_GetCoordX(i);			if (resultFSS.FSS_GetCoordY(i) == 1.0)			{				if (i > 0)				{					if ((resultFSS.FSS_GetCoordY(i-1) == 0.0) && (x > resultFSS.FSS_GetCoordX(i-1)))					{						//in this case, we insert a zero at position i//						//post("Avant insertion up = ");						//resultFSS.FSS_TextDisplay();						resultFSS.FSS_InsertPointAtPosition(resultFSS.FSS_GetCoordX(i), 0., i);						//post("Après insertion = ");						//resultFSS.FSS_TextDisplay();						//resultFSS.FSS_SetCoordX(resultFSS.FSS_GetCoordX(i), i-1);					}				}				if (i < resultFSS.FSS_GetNumberOfCoord()-1)				{					if ((resultFSS.FSS_GetCoordY(i+1) == 0.0) && (x < resultFSS.FSS_GetCoordX(i+1)))					{						//post("Avant insertion down = ");						//resultFSS.FSS_TextDisplay();						//in this case, we insert a zero at position i+1//						resultFSS.FSS_InsertPointAtPosition(resultFSS.FSS_GetCoordX(i), 0., i+1);						//post("Après insertion = ");						//resultFSS.FSS_TextDisplay();						//resultFSS.FSS_SetCoordX(resultFSS.FSS_GetCoordX(i), i+1);					}				}			}			i += 1;		}		resultFSS.FSS_CompleteWithZeros(dmin, dmax);		//post("Fuzzy Implication ->");		//resultFSS.FSS_TextDisplay();		//resultFSS.FSS_TextDisplay();		break;				//_____________________________________________________________________//		case FI_KLEENE_DIENES:		var fss1 = new FSS("");		//Build Max(1-fa, fb) FSS//		//First build 1-fa constant FSS//		fss1.FSS_AppendPoint(this.coordX[0], 1.0-fa);		fss1.FSS_AppendPoint(this.coordX[n-1], 1.0-fa);		resultFSS = LV_Operation(TCONORM_MAX, fss1, this, dmin, dmax);		//post("Fuzzy Implication ->");		//resultFSS.FSS_TextDisplay();		//y2 = Math.max(1.0-fa, y);		break;						//_____________________________________________________________________//		case FI_BROUWER_GOEDEL:		var fss1 = new FSS("");		//Build Max(fa, fb) FSS//		//First build fa constant FSS//		fss1.FSS_AppendPoint(this.coordX[0], fa);		fss1.FSS_AppendPoint(this.coordX[n-1], fa);		resultFSS = LV_Operation(TNORM_MIN, fss1, this, dmin, dmax);		//Then replace fa values by 0, and other values greater than fa by 1//		//n = resultFSS.FSS_GetNumberOfCoord();		i=0;		while ((i < resultFSS.FSS_GetNumberOfCoord()) && (i < 40))		{			//post("i=", i, "\n");			x = resultFSS.FSS_GetCoordX(i);			y = resultFSS.FSS_GetCoordY(i);			//post("y=", y, "fa=", fa, "nbre de points =", resultFSS.FSS_GetNumberOfCoord(), "\n");			if ((y > fa) || (Math.abs(y-fa) < 0.001))			{				resultFSS.FSS_SetCoordY(1.0, i);				//post("y modification to 1 => ");				//resultFSS.FSS_TextDisplay();				//insert another point//				if (i > 0)				{					if ((resultFSS.FSS_GetCoordY(i-1) < y) && (x > resultFSS.FSS_GetCoordX(i-1)))					{						//post("Insertion before\n");						resultFSS.FSS_InsertPointAtPosition(resultFSS.FSS_GetCoordX(i), y, i);						//resultFSS.FSS_TextDisplay();						i += 1;					}				}				if (i < resultFSS.FSS_GetNumberOfCoord()-1)				{					if ((resultFSS.FSS_GetCoordY(i+1) < y) && (x < resultFSS.FSS_GetCoordX(i+1)))					{						//post("Insertion after\n");						resultFSS.FSS_InsertPointAtPosition(resultFSS.FSS_GetCoordX(i), y, i+1);						//resultFSS.FSS_TextDisplay();						i += 1;					}				}			}			i += 1;		}				resultFSS.FSS_CompleteWithZeros(dmin, dmax);		//post("Fuzzy Implication ->");		//resultFSS.FSS_TextDisplay();		//resultFSS.FSS_TextDisplay();		break;						//_____________________________________________________________________//		case FI_GOGUEN:		var fss1 = new FSS("");		var fss2 = new FSS("");		//post("______\n");		if (fa == 0.0)		{			//post("fa = 0\n");			resultFSS.FSS_AppendPoint(this.coordX[0], 0.0);			resultFSS.FSS_AppendPoint(this.coordX[0], 1.0);			resultFSS.FSS_AppendPoint(this.coordX[n-1], 1.0);			resultFSS.FSS_AppendPoint(this.coordX[n-1], 0.0);			//resultFSS.FSS_TextDisplay();		}		else		{			//post("fa != 0\n");			for (i=0; i < n; i++)			{				x = this.coordX[i];				y = this.coordY[i];				fss1.FSS_AppendPoint(x, y/fa);						}			//fss1.FSS_TextDisplay();			//fss2.FSS_AppendPoint(this.coordX[0], 0.0);			fss2.FSS_AppendPoint(this.coordX[0], 0.0);			fss2.FSS_AppendPoint(this.coordX[0], 1.0);			fss2.FSS_AppendPoint(this.coordX[n-1], 1.0);			fss2.FSS_AppendPoint(this.coordX[n-1], 0.0);			//fss2.FSS_AppendPoint(this.coordX[n-1], 0.0);			//fss2.FSS_TextDisplay();			resultFSS = LV_Operation(TNORM_MIN, fss1, fss2, dmin, dmax);			//resultFSS.FSS_TextDisplay();		}		break;				//_____________________________________________________________________//		case FI_LUKASIEWICZ:		//post("______\n");		var fss1 = new FSS("");		var fss2 = new FSS("");				for (i=0; i < n; i++)		{			x = this.coordX[i];			y = this.coordY[i];			fss1.FSS_AppendPoint(x, 1.0-fa+y);					}		//fss1.FSS_TextDisplay();		fss2.FSS_AppendPoint(this.coordX[0], 0.0);		fss2.FSS_AppendPoint(this.coordX[0], 1.0);		fss2.FSS_AppendPoint(this.coordX[n-1], 1.0);		fss2.FSS_AppendPoint(this.coordX[n-1], 0.0);		//fss2.FSS_TextDisplay();		resultFSS = LV_Operation(TNORM_MIN, fss1, fss2, dmin, dmax);		//resultFSS.FSS_TextDisplay();		//y2 =  Math.min(1.0-fa+y, 1.);		break;				//_____________________________________________________________________//		case FI_MAMDANI:		var fss1 = new FSS("");		fss1.FSS_AppendPoint(this.coordX[0], 0.0);		fss1.FSS_AppendPoint(this.coordX[0], fa);		fss1.FSS_AppendPoint(this.coordX[n-1], fa);		fss1.FSS_AppendPoint(this.coordX[n-1], 0.0);		resultFSS = LV_Operation(TNORM_MIN, fss1, this, dmin, dmax);		//y2 = Math.min(fa,y);		break;				//		//_____________________________________________________________________//		case FI_LARSEN:				for (i=0; i < n; i++)		{			x = this.coordX[i];			y = this.coordY[i];			resultFSS.FSS_AppendPoint(x, fa*y);		}		break;	}		return resultFSS;}//_____________________________________________________________________//////_____________________________________________________________________//function FSS_GetSuperiorIndexOfXValue(i, x){	var j, n;	//	j = i;	n = this.coordX.length;	//post("Function GetSuperiorIndexOfXValue i = ", i, " x = ", x, "\n");		while ((this.coordX[j] < x) && (j < n))	{		j += 1;		//post("j=", j, "\n");	}	if (j == n)	{		return (n-1);	}	else	{		if (this.coordX[j] > x)		{			return (-1);		}		else		{			return j;		}	}		return i;}//____________________________________________________________________________________////Returns the number of elements identical to x starting at i position in array coordX//____________________________________________________________________________________//function FSS_GetNumberOfIdenticalXValueFrom(i, x){	var j, k, n;	//	j = i+1;	k = 1;	n = this.coordX.length;	while((j < n) && (this.coordX[j] == x))	{		k += 1;		j += 1;	}	return k;}//_____________________________________________________________________////_____________________________________________________________________//////LINGUISTIC VARIABLE PROTOTYPE - DATA AND METHODS//////_____________________________________________________________________////_____________________________________________________________________//function LV(lvName){	this.dataNameValue = lvName;	//this.preciseVal = 0;	this.modellingFSS = new Array();	//	//current input data value (initially 0.0)//	this.currentDataValue = 0.0;	//fuzzySubsetNumber : number of fuzzy subsets used//	this.fuzzySubsetNumber = 0;		//min, max and average for the input data//	this.dataMin = MAX_APP;	this.dataMax = MIN_APP;		//service methods//	this.LV_SetDataNameValue = LV_SetDataNameValue;	this.LV_GetDataNameValue = LV_GetDataNameValue;	this.LV_SetCurrentDataValue = LV_SetCurrentDataValue;	this.LV_GetCurrentDataValue = LV_GetCurrentDataValue;	this.LV_SetFuzzySubsetNumber = LV_SetFuzzySubsetNumber;	this.LV_GetFuzzySubsetNumber = LV_GetFuzzySubsetNumber;		this.LV_SetDataMin = LV_SetDataMin;	this.LV_GetDataMin = LV_GetDataMin;	this.LV_SetDataMax = LV_SetDataMax;	this.LV_GetDataMax = LV_GetDataMax;		this.LV_alphaCut = LV_alphaCut;	this.LV_CopyFrom = LV_CopyFrom;	this.LV_GetModellingFSS = LV_GetModellingFSS;	//other methods//	this.LV_Operation = LV_Operation;	this.LV_implementedOperation = LV_implementedOperation;	this.LV_GetIntersectionValue = LV_GetIntersectionValue;		this.LV_displaysParameters = LV_displaysParameters;	this.LV_displaysDataProperties = LV_displaysDataProperties;	this.LV_displaysFSSData = LV_displaysFSSData;	this.LV_FSSSizing = LV_FSSSizing;	this.LV_FSSInstantiation = LV_FSSInstantiation;		this.LV_parseDualTNormCoNorm = LV_parseDualTNormCoNorm;		this.LV_getTNormLabel = LV_getTNormLabel;	this.LV_getTCoNormLabel = LV_getTCoNormLabel;	this.LV_getDualTNormCoNormLabel = LV_getDualTNormCoNormLabel;	}//_____________________________________________________________________//function LV_SetDataNameValue(lvName){	this.dataNameValue = lvName;}//_____________________________________________________________________//function LV_GetDataNameValue(){	return this.dataNameValue;}//_____________________________________________________________________//function LV_SetCurrentDataValue(v){	this.currentDataValue = v;}//_____________________________________________________________________//function LV_GetCurrentDataValue(){	return this.currentDataValue;}//_____________________________________________________________________//function LV_SetFuzzySubsetNumber(n){	this.fuzzySubsetNumber = n;}//_____________________________________________________________________//function LV_GetFuzzySubsetNumber(){	return this.fuzzySubsetNumber;}//_____________________________________________________________________////_____________________________________________________________________//function LV_SetDataMin(x){	this.dataMin = x;}//_____________________________________________________________________//function LV_GetDataMin(){	return this.dataMin;}//_____________________________________________________________________//function LV_SetDataMax(x){	this.dataMax = x;}//_____________________________________________________________________//function LV_GetDataMax(){	return this.dataMax;}//_____________________________________________________________________//function LV_GetModellingFSS(i){	if ((i > -1) && (i < this.fuzzySubsetNumber))		{			return this.modellingFSS[i];		}}//_____________________________________________________________________//function LV_Operation(operationID, fss1, fss2, dmin, dmax){	var fssInter = new FSS("");	var xCoordinateList = new Array();	var y1_prec_a, y1_prec_b, y2_prec_a, y2_prec_b, y1_suiv_a, y1_suiv_b, y2_suiv_a, y2_suivb;	var nx1, nx2, nx, x_prec, x_suiv;	var i, j, i1_prec, i2_prec, i1_suiv, i2_suiv, ind;	var n1_prec, n2_prec, n1_suiv, n2_suiv;	//var x0, y0;	var elementFound = false;	var intersectionResult = new Array(3);	//	//post("==========================\nLV_Operation ", operationID, "\n");	nx1 = fss1.FSS_GetNumberOfCoord();	nx2 = fss2.FSS_GetNumberOfCoord();	//post("nx1=", nx1, " nx2=", nx2, "\n");	//	//we build the list of xcoordinates necessary//	for (i=0 ; i < nx1; i++)	{		xCoordinateList = insertIntoList(fss1.FSS_GetCoordX(i), xCoordinateList);	}	for (i=0 ; i < nx2; i++)	{		xCoordinateList = insertIntoList(fss2.FSS_GetCoordX(i), xCoordinateList);	}	//post("Number of x coordinates = ", xCoordinateList.length, "\n");	//	if ((nx1 > 0) && (nx2 > 0))	{		//if there is at least one value in each FSS//		//initialization//		i1_prec = 0;		i2_prec = 0;		nx = xCoordinateList.length;		x_prec = xCoordinateList[0];		//move forward to find next index for fss1//		ind = fss1.FSS_GetSuperiorIndexOfXValue(i1_prec, x_prec);		//post("Ind = ", ind, "\n");		if (ind < 0)		{			n1_prec = 1;			y1_prec_a = fss1.FSS_GetMembershipValue(x_prec);			y1_prec_b = y1_prec_a;		}		else		{			i1_prec = ind;			n1_prec = fss1.FSS_GetNumberOfIdenticalXValueFrom(i1_prec, x_prec);			//post("n1_prec = ", n1_prec, "\n");			y1_prec_a = fss1.FSS_GetCoordY(i1_prec);			//post("y1_prec_a = ", y1_prec_a, "\n");			y1_prec_b = fss1.FSS_GetCoordY(i1_prec+n1_prec-1);			//post("y1_prec_b = ", y1_prec_b, "\n");		}		//move forward to find next index for fss2//		ind = fss2.FSS_GetSuperiorIndexOfXValue(i2_prec, x_prec);		//post("Ind = ", ind, "\n");		if (ind < 0)		{			n2_prec = 1;			y2_prec_a = fss2.FSS_GetMembershipValue(x_prec);			//post("y2_prec_a = ", y2_prec_a, "\n");			y2_prec_b = y2_prec_a;		}		else		{			i2_prec = ind;			n2_prec = fss2.FSS_GetNumberOfIdenticalXValueFrom(i2_prec, x_prec);			y2_prec_a = fss2.FSS_GetCoordY(i2_prec);			//post("y2_prec_a = ", y2_prec_a, "\n");			y2_prec_b = fss2.FSS_GetCoordY(i2_prec+n2_prec-1);			//post("y2_prec_b = ", y2_prec_b, "\n");		}		i = 1;		//				while (i < nx)		{			//post("Debut boucle while i=", i, "\n");			x_suiv = xCoordinateList[i];			/*			if (i1_prec < nx1 - 1)			{				i1_suiv = i1_prec+1;			}			*/			ind = fss1.FSS_GetSuperiorIndexOfXValue(i1_prec, x_suiv);			//post("Ind = ", ind, "\n");			if (ind < 0)			{				i1_suiv = i1_prec;				n1_suiv = 1;				y1_suiv_a = fss1.FSS_GetMembershipValue(x_suiv);				y1_suiv_b = y1_suiv_a;			}			else			{				i1_suiv = ind;				n1_suiv = fss1.FSS_GetNumberOfIdenticalXValueFrom(i1_suiv, x_suiv);				y1_suiv_a = fss1.FSS_GetCoordY(i1_suiv);				y1_suiv_b = fss1.FSS_GetCoordY(i1_suiv+n1_suiv-1);			}			//move forward to find next index for fss2//			/*			if (i2_prec < nx2 - 1)			{				i2_suiv = i2_prec+1;			}			*/			ind = fss2.FSS_GetSuperiorIndexOfXValue(i2_prec, x_suiv);			//post("Ind = ", ind, "\n");			if (ind < 0)			{				i2_suiv = i2_prec;				n2_suiv = 1;				y2_suiv_a = fss2.FSS_GetMembershipValue(x_suiv);				y2_suiv_b = y2_suiv_a;			}			else			{				i2_suiv = ind;				n2_suiv = fss2.FSS_GetNumberOfIdenticalXValueFrom(i2_suiv, x_suiv);				y2_suiv_a = fss2.FSS_GetCoordY(i2_suiv);				y2_suiv_b = fss2.FSS_GetCoordY(i2_suiv+n2_suiv-1);			}						//post("_________________________________________________________\n");			//post("x_prec = ", x_prec, " x_suiv = ", x_suiv, "\n");			//post("i1_prec = ", i1_prec, " i1_suiv = ", i1_suiv, "\n");			//post("i2_prec = ", i2_prec, " i2_suiv = ", i2_suiv, "\n");			//post("n1_prec = ", n1_prec, " n1_suiv = ", n1_suiv, " n2_prec = ", n2_prec, " n2_suiv = ", n2_suiv, "\n");			//post("Pour fss1 : ", y1_prec_a, y1_prec_b, y1_suiv_a, y1_suiv_b,"\n");			//post("Pour fss2 : ", y2_prec_a, y2_prec_b, y2_suiv_a, y2_suiv_b,"\n");						//			//first case : we only have one element in each list//			//it is the classical situation with 4 points, defining 2 segments//			if ((n1_prec == 1) && (n2_prec == 1) && (n1_suiv == 1) && (n2_suiv == 1))			{				intersectionResult=segmentIntersection(x_prec, y1_prec_a, y2_prec_a, x_suiv, y1_suiv_a, y2_suiv_a);				if (intersectionResult[0] == IS_NONE)				{					//segments are parallel//					//post("Parallel segments\n");					fssInter.FSS_AppendPoint(x_prec, LV_implementedOperation(operationID, y1_prec_a, y2_prec_a));				}				else				{					//post("Intersection of segments  \n");					//there is an intersection of the two segments//					fssInter.FSS_AppendPoint(x_prec, LV_implementedOperation(operationID, y1_prec_a, y2_prec_a));					fssInter.FSS_AppendPoint(intersectionResult[1], intersectionResult[2]);					//post("After insertion \n");					//fssInter.FSS_TextDisplay();					}				if ((i1_suiv+n1_suiv == nx1) && (i2_suiv+n2_suiv == nx2))				{					//if last point, we add it also//					//post("Last point added\n");					fssInter.FSS_AppendPoint(x_suiv, LV_implementedOperation(operationID, y1_suiv_a, y2_suiv_a));				}			}			else			{				//post("At least a vertical segment\n")				//second case: there is at least a vertical segment//				fssInter.FSS_AppendPoint(x_prec, LV_implementedOperation(operationID, y1_prec_a, y2_prec_a));				//post("Add 1st point");				//fssInter.FSS_TextDisplay();								//for the second point//				if ((y1_prec_b != y1_prec_a) || (y2_prec_b != y2_prec_a))				{					fssInter.FSS_AppendPoint(x_prec, LV_implementedOperation(operationID, y1_prec_b, y2_prec_b));					//post("Add possible 2nd point");					//fssInter.FSS_TextDisplay();				}				intersectionResult=segmentIntersection(x_prec, y1_prec_b, y2_prec_b, x_suiv, y1_suiv_a, y2_suiv_a);				if (intersectionResult[0] != IS_NONE)				{					fssInter.FSS_AppendPoint(intersectionResult[1], intersectionResult[2]);					//post("Add possible intersection");					//fssInter.FSS_TextDisplay();				}				//for the last point//				if ((i1_suiv+n1_suiv == nx1) && (i2_suiv+n2_suiv == nx2))				{					//post("For the last point=>\n");					intersectionResult=segmentIntersection(x_prec, y1_prec_b, y2_prec_b, x_suiv, y1_suiv_a, y2_suiv_a);					if (intersectionResult[0] != IS_NONE)					{						fssInter.FSS_AppendPoint(intersectionResult[1], intersectionResult[2]);						//post("Add possible intersection");						//fssInter.FSS_TextDisplay();					}					fssInter.FSS_AppendPoint(x_suiv, LV_implementedOperation(operationID, y1_suiv_a, y2_suiv_a));					//post("Add 1st point");					//fssInter.FSS_TextDisplay();					if ((y1_suiv_b != y1_suiv_a) || (y2_suiv_b != y2_suiv_a))					{						fssInter.FSS_AppendPoint(x_suiv, LV_implementedOperation(operationID, y1_suiv_b, y2_suiv_b));						//post("Add possible 2nd point");						//fssInter.FSS_TextDisplay();					}				}			}						//prepare next loop//			i += 1;			i1_prec = i1_suiv;			i2_prec = i2_suiv;			n1_prec = n1_suiv;			n2_prec = n2_suiv;			x_prec = x_suiv;			y1_prec_a = y1_suiv_a;			y1_prec_b = y1_suiv_b;			y2_prec_a = y2_suiv_a;			y2_prec_b = y2_suiv_b;			//			//fssInter.FSS_TextDisplay();		}				fssInter.FSS_Simplify();		//post("After simplication==>");		//fssInter.FSS_TextDisplay();		//if the first point x is not at ordinate y=0, let's add the point (x, 0) at the beginning//		fssInter.FSS_CompleteWithZeros(dmin, dmax);		//post("After completing with zeros==>");		//fssInter.FSS_TextDisplay();		return fssInter;	}		else	{		//return null FSS//		return fssInter;	}	}//_____________________________________________________________________//////_____________________________________________________________________//function LV_implementedOperation(operationID, x, y){	//post("operationID = ", operationID, " x = ", x, " y = ", y, "\n");	switch (operationID)	{		case TNORM_MIN:		return Math.min(x,y);		break;				case TNORM_PROD:		return x*y;		break;				case TNORM_MAXSUM:		return Math.max(x+y-1.0, 0.0);		break;				case TCONORM_MAX:		return Math.max(x, y);		break;				case TCONORM_SUMMINUSPROD:		return (x+y-x*y);		break;				case TCONORM_MINSUM:		return Math.min(x+y, 1.0);		break;	}}//_____________________________________________________________________//function LV_GetIntersectionValue(fss1, fss2, dmin, dmax){	var fssInter = new FSS("intersection");	//post("GetIntersectionValue = ", this.tNormID, "\n");	fssInter = this.LV_Operation(this.tNormID, fss1, fss2, dmin, dmax);	return fssInter.FSS_GetYMax();}	//_____________________________________________________________________//////function LV_parseDualTNormCoNorm(x)////This function parses the string received, supposed to be the id of a dual tNorm and CoNorm selection//////_____________________________________________________________________//function LV_parseDualTNormCoNorm(x){	//post(x, "\n");	switch(x)	{		case DUAL_MIN_MAX_ID:		this.myDualTNormAndCoNorm = DUAL_MIN_MAX;		this.tNormID = TNORM_MIN;		this.tCoNormID = TCONORM_MAX;		return NO_ERROR;		break;				case DUAL_PROD_SUMMINUSPROD_ID:		this.myDualTNormAndCoNorm = DUAL_PROD_SUMMINUSPROD;		this.tNormID = TNORM_PROD;		this.tCoNormID = TCONORM_SUMMINUSPROD;		return NO_ERROR;		break;				case DUAL_MAXSUM_MINSUM_ID:		this.myDualTNormAndCoNorm = DUAL_MAXSUM_MINSUM;		this.tNormID = TNORM_MAXSUM;		this.tCoNormID = TCONORM_MINSUM;		return NO_ERROR;		break;				default:		return WRONG_DUALTNORMCONORM_PARAMETER;		break;	}}//_____________________________________________________________________//////function displaysParameters()////This function displays the global variables////_____________________________________________________________________//function LV_displaysParameters(){	var i;	post("dataName = ", this.dataNameValue, "\n");	post("fuzzySubsetNumber = ", this.fuzzySubsetNumber, "\n");}//_____________________________________________________________________//////function displaysDataProperties()////This function displays the global variables////_____________________________________________________________________//function LV_displaysDataProperties(){	post("\n");	post("minimum = ", this.dataMin, "\n");	post("maximum = ", this.dataMax, "\n");}//_____________________________________________________________________//////function LV_displaysFSSData()////This function displays the information for each FSS in LV class////_____________________________________________________________________//function LV_displaysFSSData(){	var i;	//this.fssVal.FSS_TextDisplay();	for (i = 0; i < this.fuzzySubsetNumber; i++)	{		this.modellingFSS[i].FSS_TextDisplay();	}}function LV_FSSSizing(){	this.modellingFSS = new Array(this.fuzzySubsetNumber);}function LV_FSSInstantiation(i, myName){	this.modellingFSS[i] = new FSS(myName);}//_____________________________________________________________________//////_____________________________________________________________________//function LV_getTNormLabel(x){	switch(x)	{	case TNORM_MIN:	return TNORM_MIN_ID;	break;		case TNORM_PROD:	return TNORM_PROD_ID;	break;		case TNORM_MAXSUM:	return TNORM_MAXSUM_ID;	break;	}}//_____________________________________________________________________//////_____________________________________________________________________//function LV_getTCoNormLabel(x){	switch(x)	{	case TCONORM_MAX:	return TCONORM_MAX_ID;	break;		case TCONORM_SUMMINUSPROD:	return TCONORM_SUMMINUSPROD_ID;	break;		case TCONORM_MINSUM:	return TCONORM_MINSUM_ID;	break;	}}//_____________________________________________________________________//////_____________________________________________________________________//function LV_getDualTNormCoNormLabel(x){	switch(x)	{	case DUAL_MIN_MAX:	return DUAL_MIN_MAX_ID;	break;		case DUAL_PROD_SUMMINUSPROD:	return DUAL_PROD_SUMMINUSPROD_ID;	break;		case DUAL_MAXSUM_MINSUM:	return DUAL_MAXSUM_MINSUM_ID;	break;	}}//_____________________________________________________________________//////_____________________________________________________________________//function LV_alphaCut(fss1, alpha){	var fss2 = new FSS("alphaCut");	var i, n, x, y;	n = fss1.FSS_GetNumberOfCoord();	for (i=0; i < n; i++)	{		x = fss1.FSS_GetCoordX(i);		y = fss1.FSS_GetCoordY(i);		fss2.AddPoint(x, Math.min(y, alpha));	}	return fss2;}//_____________________________________________________________________//////_____________________________________________________________________//function LV_CopyFrom(lv2){	var i, n;	//post("1\n");	this.dataNameValue = lv2.LV_GetDataNameValue();	//post("2\n");	//this.fssVal = new FSS(lv2.LV_GetDataNameValue());		//	//post("3\n");	//this.lvType = lv2.LV_GetLV_Type();	//	//post("4\n");	this.currentDataValue = lv2.LV_GetCurrentDataValue();	//	//post("5\n");	this.fuzzySubsetNumber = lv2.LV_GetFuzzySubsetNumber();	n = this.fuzzySubsetNumber;	for (i = 0; i < n; i++)	{		this.modellingFSS.push(lv2.LV_GetModellingFSS(i));	}	//	//this.fuzzyficationMethodID = lv2.LV_GetFuzzyficationMethodID();	//	//this.partitioningMethodID = lv2.LV_GetPartitionMethodID();	//	//this.trainingModeID = lv2.LV_GetTrainingModeID();	//	//this.leftBoundaryValue = lv2.LV_GetLeftBoundaryValue();	//	//this.rightBoundaryValue = lv2.LV_GetRightBoundaryValue();	//	//this.halfKernelValue = lv2.LV_GetHalfKernelValue();	//	this.dataMin = lv2.LV_GetDataMin();	this.dataMax = lv2.LV_GetDataMax();}